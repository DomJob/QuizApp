<!DOCTYPE html>
<html lang="en">
  <head>
    <script>
      // Quiz will be loaded from a user-uploaded file

      function escapeHtml(text) {
        return String(text)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }
      function unescapeHtml(text) {
        return String(text)
          .replace(/&amp;/g, "&")
          .replace(/&lt;/g, "<")
          .replace(/&gt;/g, ">")
          .replace(/&quot;/g, '"')
          .replace(/&#39;/g, "'");
      }

      function parseMarkdown(input) {
        if (!input) return "";

        let text = input.replace(/\r\n/g, "\n");

        // Extract fenced code blocks to placeholders to avoid formatting inside them
        const codeBlocks = [];
        text = text.replace(
          /```(\w+)?\s*([\s\S]*?)```/g,
          (match, lang, code) => {
            const placeholder = `__CODEBLOCK_${codeBlocks.length}__`;
            // Trim extra whitespace from code blocks to prevent unwanted line breaks
            codeBlocks.push({ lang: lang || "", code: code.trim() });
            return placeholder;
          }
        );
        text = escapeHtml(text);

        // Inline code
        text = text.replace(
          /`([^`]+)`/g,
          (m, code) => `<code>${code}</code>`
        );

        // Bold
        text = text.replace(/\*\*(.+?)\*\*/g, "<b>$1</b>");

        // Italic
        text = text.replace(/\*(.+?)\*/g, "<i>$1</i>");

        // Newlines -> <br/>
        text = text.replace(/\n\n/g, "<br/><br />").replace(/\n/g, "<br/>");

        // Restore code blocks
        text = text.replace(/__CODEBLOCK_(\d+)__/g, (m, idxStr) => {
          const idx = Number(idxStr);
          const blk = codeBlocks[idx];
          const escaped = escapeHtml(String(blk.code).replace(/\r\n/g, "\n"));
          const langClass = blk.lang ? ` class="language-${blk.lang}"` : "";
          return `<pre><code${langClass}>${escaped}</code></pre>`;
        });

        return text;
      }

      function parseQuestionBlock(block) {
        // Preserve blank lines; strip only trailing carriage returns
        const lines = block
          .trim()
          .split("\n")
          .map((l) => l.replace(/\r$/, ""));
        let source = "";
        let question = "";
        let choices = [];
        let i = 0;

        // Find source
        if (lines[i] && lines[i].trim().startsWith("Source:")) {
          source = lines[i].trim().replace(/^Source:\s*/, "");
          i++;
        }

        // Find question
        let questionLines = [];
        // Find the line that starts with "Question:"
        while (i < lines.length && !lines[i].trim().startsWith("Question:")) {
          i++;
        }
        if (i < lines.length && lines[i].trim().startsWith("Question:")) {
          // Remove "Question:" and start collecting question lines (preserving indentation and blanks)
          questionLines.push(lines[i].replace(/^(\s*)Question:\s*/, "$1"));
          i++;
          // Collect all lines until we hit a choice line (starts with [)
          while (i < lines.length && !lines[i].trim().match(/^\[[^\]]*\]/)) {
            questionLines.push(lines[i]);
            i++;
          }
        }
        question = questionLines.join("\n").replace(/^\n+|\n+$/g, "");

        // Parse choices
        while (i < lines.length) {
          // Choices start with [<answer>] <text>
          const match = lines[i].match(/^\s*\[([^\]]*)\]\s?(.*)$/);
          if (match) {
            let answer = match[1].trim();
            let text = match[2] || "";
            // Collect multiline choice text
            i++;
            while (i < lines.length && !lines[i].trim().match(/^\[[^\]]*\]/)) {
              text += "\n" + lines[i];
              i++;
            }
            choices.push({
              text: text.replace(/^\n+|\n+$/g, ""),
              answer: answer,
            });
          } else {
            i++;
          }
        }

        return {
          source,
          question: parseMarkdown(question),
          choices: choices.map((c) => ({
            text: parseMarkdown(c.text),
            answer: c.answer,
          })),
          originalBlock: block.trim(), // Store the original block text
        };
      }

      function parseQuestionsFile(content) {
        return content
          .replace(/\r\n/g, "\n")
          .trim()
          .split("-----")
          .filter((block) => block.trim() !== "")
          .map(parseQuestionBlock);
      }
    </script>
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🧠</text></svg>"
    />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Quiz</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #f8fafc;
        /* slate-50 */
        --panel: #ffffff;
        --panel-2: #ffffff;
        --text: #111827;
        /* slate-900 */
        --muted: #6b7280;
        /* slate-500 */
        --accent: #4f46e5;
        /* indigo-600 */
        --accent-2: #06b6d4;
        /* cyan-500 */
        --green: #16a34a;
        --red: #dc2626;
        --yellow: #ca8a04;
        --border: #e5e7eb;
        /* gray-200 */
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: var(--text);
        background: radial-gradient(
            1200px 800px at 0% -20%,
            rgba(79, 70, 229, 0.06),
            rgba(6, 182, 212, 0.04) 30%,
            transparent 60%
          ),
          radial-gradient(
            800px 600px at 100% 120%,
            rgba(79, 70, 229, 0.06),
            rgba(6, 182, 212, 0.04) 30%,
            transparent 60%
          ),
          var(--bg);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 24px;
      }

      .app {
        width: 100%;
        max-width: 960px;
      }

      .card {
        background: linear-gradient(180deg, var(--panel), var(--panel-2));
        border: 1px solid var(--border);
        border-radius: 16px;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.08),
          0 1px 0 rgba(255, 255, 255, 0.6) inset;
        overflow: hidden;
      }

      .card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 18px 20px;
        border-bottom: 1px solid var(--border);
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0.02),
          rgba(0, 0, 0, 0)
        );
      }

      .source {
        font-size: 14px;
        color: var(--muted);
        display: flex;
        gap: 8px;
        align-items: center;
        align-self: flex-start;
        /* ensure upper-left alignment */
      }

      .source .dot {
        width: 6px;
        height: 6px;
        border-radius: 3px;
        background: var(--accent-2);
        box-shadow: 0 0 14px var(--accent-2);
      }

      .progress {
        font-size: 14px;
        color: var(--muted);
      }

      .card-body {
        padding: 20px;
      }

      .question-text {
        font-size: 18px;
        line-height: 1.6;
        margin: 4px 0 16px 0;
      }

      .choices {
        display: grid;
        gap: 10px;
      }

      .choice {
        border: 1px solid var(--border);
        background: #ffffff;
        padding: 12px 14px;
        border-radius: 12px;
        display: flex;
        align-items: flex-start;
        gap: 10px;
        transition: border-color 1s ease, background 0.15s ease,
          box-shadow 0.15s ease, transform 0.12s ease;
      }

      .choice:hover {
        border-color: rgba(79, 70, 229, 0.35);
        background: rgba(79, 70, 229, 0.05);
        box-shadow: inset 0 0 0 1px rgba(79, 70, 229, 0.12);
      }

      .choice.correct {
        border-color: rgba(22, 163, 74, 0.7);
        background: rgba(22, 163, 74, 0.08);
      }

      .choice.incorrect {
        border-color: rgba(220, 38, 38, 0.7);
        background: rgba(220, 38, 38, 0.08);
      }

      .choice .label {
        flex: 1;
      }

      .choice .badge {
        font-size: 12px;
        color: var(--muted);
      }

      .controls {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 14px 20px;
        border-top: 1px solid var(--border);
        background: linear-gradient(
          0deg,
          rgba(0, 0, 0, 0.02),
          rgba(0, 0, 0, 0)
        );
      }

      .left-controls,
      .right-controls {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      button {
        background: linear-gradient(
          180deg,
          rgba(79, 70, 229, 0.92),
          rgba(79, 70, 229, 0.78)
        );
        color: white;
        border: none;
        padding: 10px 14px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
        letter-spacing: 0.2px;
        transition: transform 0.05s ease, opacity 0.2s ease,
          box-shadow 0.15s ease;
        box-shadow: 0 6px 18px rgba(79, 70, 229, 0.3);
      }

      button.secondary {
        background: #ffffff;
        color: var(--text);
        border: 1px solid var(--border);
        box-shadow: 0 1px 0 rgba(0, 0, 0, 0.02);
      }

      button[disabled] {
        opacity: 0.5;
        cursor: not-allowed;
      }

      button:active {
        transform: translateY(1px);
      }

      .status {
        font-size: 14px;
        color: var(--muted);
      }

      .spinner-wrap {
        display: grid;
        place-items: center;
        height: 60vh;
      }

      .spinner {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        border: 4px solid rgba(0, 0, 0, 0.08);
        border-top-color: var(--accent);
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .hidden {
        display: none;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      /* Rendered markdown basics */
      code {
        background: rgba(0, 0, 0, 0.06);
        padding: 2px 6px;
        border-radius: 6px;
      }

      pre {
        background: rgba(0, 0, 0, 0.04);
        padding: 12px;
        border-radius: 10px;
        overflow: auto;
        margin: 0;
      }

      pre code {
        background: transparent;
        padding: 0;
        border-radius: 0;
        /* Prevent line highlighting inside code blocks */
        line-height: 1.4;
        white-space: pre;
        font-family: "Lucida Console", "SF Mono", Monaco, "Cascadia Code",
          "Roboto Mono", Consolas, "Courier New", monospace;
      }

      a {
        color: var(--accent-2);
      }

      select {
        background: #ffffff;
        color: var(--text);
        border: 1px solid var(--border);
        padding: 6px 8px;
        border-radius: 8px;
      }

      input[type="radio"],
      input[type="checkbox"] {
        transform: translateY(3px);
      }

      .setting-item {
        padding: 16px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: #ffffff;
        transition: border-color 0.15s ease, background 0.15s ease,
          box-shadow 0.15s ease;
      }

      .setting-item:hover {
        border-color: rgba(79, 70, 229, 0.35);
        background: rgba(79, 70, 229, 0.02);
      }

      .setting-item input[type="checkbox"]:checked + div {
        color: var(--accent);
      }

      /* Better-looking upload dropzone */
      .dropzone {
        border: 2px dashed var(--border);
        border-radius: 14px;
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0.015),
          rgba(0, 0, 0, 0)
        );
        padding: 24px;
        display: grid;
        gap: 10px;
        place-items: center;
        text-align: center;
        cursor: pointer;
        transition: border-color 0.15s ease, background 0.15s ease,
          box-shadow 0.15s ease;
        /* Mobile improvements */
        min-height: 120px;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }

      .dropzone:hover,
      .dropzone.hover {
        border-color: rgba(79, 70, 229, 0.45);
        background: rgba(79, 70, 229, 0.04);
        box-shadow: inset 0 0 0 1px rgba(79, 70, 229, 0.1);
      }

      /* Mobile-specific active state */
      @media (hover: none) and (pointer: coarse) {
        .dropzone:active {
          border-color: rgba(79, 70, 229, 0.6);
          background: rgba(79, 70, 229, 0.08);
          transform: scale(0.98);
        }
      }

      .dz-icon {
        width: 40px;
        height: 40px;
        border-radius: 999px;
        display: grid;
        place-items: center;
        background: rgba(79, 70, 229, 0.08);
        color: var(--accent);
        font-weight: 700;
        box-shadow: 0 6px 18px rgba(79, 70, 229, 0.12) inset;
      }

      .dz-title {
        font-weight: 700;
      }

      .dz-subtitle {
        font-size: 14px;
        color: var(--muted);
      }

      /* Drag-and-drop ordering styles */
      .dnd-item {
        display: flex;
        align-items: center;
        gap: 10px;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        touch-action: pan-y;
        cursor: grab;
        will-change: transform;
      }

      .dnd-item:active {
        cursor: grabbing;
      }

      .dnd-item.dragging {
        opacity: 0.8;
        z-index: 1000;
        position: relative;
      }

      .dnd-handle {
        width: 24px;
        height: 24px;
        border-radius: 6px;
        display: grid;
        place-items: center;
        background: rgba(0, 0, 0, 0.04);
        color: var(--muted);
        font-weight: 700;
        cursor: grab;
        touch-action: none;
      }

      .dnd-item.dragging .dnd-handle {
        cursor: grabbing;
        background: rgba(79, 70, 229, 0.1);
        color: var(--accent);
      }

      .dnd-item.dragging {
        opacity: 1;
      }

      .dnd-index {
        min-width: 28px;
        height: 24px;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.04);
        display: grid;
        place-items: center;
        font-size: 12px;
        color: var(--muted);
        font-weight: 600;
      }

      /* Uploader URL option */
      .or-sep {
        margin: 16px 0 8px;
        text-align: center;
        color: var(--muted);
        font-size: 13px;
      }

      .url-loader {
        display: flex;
        gap: 10px;
        align-items: center;
        justify-content: center;
        margin-top: 8px;
        flex-wrap: wrap;
      }

      .url-input {
        flex: 1 1 320px;
        max-width: 100%;
        background: #ffffff;
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 10px 12px;
        font-family: inherit;
        font-size: 14px;
      }

      /* GitHub logo styles */
      .github-link {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
        transition: transform 0.2s ease;
      }

      .github-link:hover {
        transform: scale(1.1);
      }

      .github-link svg {
        width: 32px;
        height: 32px;
        fill: var(--muted);
        transition: fill 0.2s ease;
      }

      .github-link:hover svg {
        fill: var(--text);
      }
    </style>
    <script>
      // Quiz logic kept self-contained and legible for future extension
      (function () {
        /** @typedef {{question: string, source: string, choices: {answer: string, text: string}[]}} RawQuestion */

        /** Global quiz state */
        const state = {
          questions: [],
          rawQuestions: [],
          currentIndex: 0,
          // Stores responses per question index
          // single -> number (choice index)
          // multiple -> Set<number>
          // select -> Map<number, string>
          responses: new Map(),
          revealed: new Set(),
        };

        const DEFAULT_URL = "https://quiz.qot.app/example";

        /** DOM refs */
        const refs = {};

        function $(sel) {
          return document.querySelector(sel);
        }

        function shuffle(array) {
          const arr = array.slice();
          for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
          return arr;
        }

        function isX(value) {
          return (
            String(value || "")
              .trim()
              .toLowerCase() === "x"
          );
        }

        function detectType(q) {
          const answers = q.choices
            .map((c) => c.answer)
            .filter((a) => String(a).trim() !== "");
          const xCount = answers.filter(isX).length;
          const hasNonX = answers.some((a) => !isX(a));
          if (answers.length > 0 && hasNonX && xCount === 0) return "select";
          if (xCount <= 1) return "single";
          return "multiple";
        }

        function buildSelectOptions(choices) {
          const distinct = Array.from(
            new Set(choices.map((c) => String(c.answer).trim()).filter(Boolean))
          );
          const allNumeric = distinct.every((v) => /^-?\d+(\.\d+)?$/.test(v));
          if (allNumeric) {
            return distinct.sort((a, b) => Number(a) - Number(b));
          }
          return distinct.sort((a, b) => a.localeCompare(b));
        }

        function naturalSort(a, b) {
          // Split by pipe and trim whitespace
          const partsA = a.split('|').map(part => part.trim());
          const partsB = b.split('|').map(part => part.trim());
          
          // Compare each part
          const maxLength = Math.max(partsA.length, partsB.length);
          
          for (let i = 0; i < maxLength; i++) {
            const partA = partsA[i] || '';
            const partB = partsB[i] || '';
            
            // Extract numbers from the beginning of each part
            const numMatchA = partA.match(/^(\d+)/);
            const numMatchB = partB.match(/^(\d+)/);
            
            if (numMatchA && numMatchB) {
              // Both parts start with numbers, compare numerically
              const numA = parseInt(numMatchA[1], 10);
              const numB = parseInt(numMatchB[1], 10);
              if (numA !== numB) {
                return numA - numB;
              }
              // Numbers are equal, compare the rest of the part
              const restA = partA.substring(numMatchA[1].length);
              const restB = partB.substring(numMatchB[1].length);
              if (restA !== restB) {
                return restA.localeCompare(restB);
              }
            } else if (numMatchA) {
              // Only partA starts with a number, it comes first
              return -1;
            } else if (numMatchB) {
              // Only partB starts with a number, it comes first
              return 1;
            } else {
              // Neither part starts with a number, compare lexicographically
              if (partA !== partB) {
                return partA.localeCompare(partB);
              }
            }
          }
          
          // All parts are equal
          return 0;
        }

        function buildQuizData(raw, shouldShuffle = true) {
          let processedQuestions;
          if (shouldShuffle) {
            processedQuestions = shuffle(raw);
          } else {
            // Sort naturally by source property (handles numerical sorting)
            processedQuestions = raw.slice().sort((a, b) => {
              const sourceA = (a.source || "").toLowerCase();
              const sourceB = (b.source || "").toLowerCase();
              return naturalSort(sourceA, sourceB);
            });
          }
          
          return processedQuestions.map((q, idx) => {
            const type = detectType(q);
            const choices = shuffle(
              q.choices.map((c, i) => ({ ...c, originalIndex: i }))
            );
            const selectOptions =
              type === "select" ? buildSelectOptions(choices) : [];
            return { ...q, type, choices, selectOptions, index: idx };
          });
        }

        function loadHtmlInto(el, html) {
          el.innerHTML = html;
        }

        function ensureResponseFor(index) {
          if (!state.responses.has(index)) {
            const q = state.questions[index];
            if (q.type === "single") state.responses.set(index, -1);
            else if (q.type === "multiple")
              state.responses.set(index, new Set());
            else if (q.type === "select") state.responses.set(index, new Map());
          }
        }

        function isQuestionAnswered(q, resp) {
          if (q.type === "single") {
            return typeof resp === "number" && resp >= 0;
          }
          if (q.type === "multiple") {
            return resp instanceof Set && resp.size > 0;
          }
          if (q.type === "select") {
            const map = resp instanceof Map ? resp : new Map();
            for (const v of map.values()) {
              if (String(v || "").trim() !== "") return true;
            }
            return false;
          }
          return false;
        }

        function countAnsweredQuestions() {
          let answered = 0;
          state.questions.forEach((q, idx) => {
            ensureResponseFor(idx);
            const resp = state.responses.get(idx);
            if (isQuestionAnswered(q, resp)) answered += 1;
          });
          return answered;
        }

        function onPrev() {
          if (state.currentIndex > 0) {
            state.currentIndex -= 1;
            render();
          }
        }

        function onNext() {
          if (state.currentIndex < state.questions.length - 1) {
            state.currentIndex += 1;
            render();
          } else {
            // Block finishing when nothing is answered
            if (countAnsweredQuestions() === 0) return;
            showResults();
          }
        }

        function onReveal() {
          const idx = state.currentIndex;
          if (state.revealed.has(idx)) {
            state.revealed.delete(idx);
          } else {
            state.revealed.add(idx);
          }
          renderChoices();
          updateRevealButton();
        }

        function onCopyToClipboard() {
          const currentQuestion = state.questions[state.currentIndex];
          const rawQuestion = state.rawQuestions.find(q => 
            q.source === currentQuestion.source && 
            q.question === currentQuestion.question
          );
          
          if (rawQuestion && rawQuestion.originalBlock) {
            // Add five dashes at the end
            const blockText = rawQuestion.originalBlock + "\n-----\n";
            
            // Copy to clipboard
            navigator.clipboard.writeText(blockText).then(() => {
              // Show feedback
              const originalText = refs.clipboardBtn.textContent;
              refs.clipboardBtn.textContent = "✓";
              refs.clipboardBtn.style.background = "var(--green)";
              refs.clipboardBtn.style.color = "white";
              
              setTimeout(() => {
                refs.clipboardBtn.textContent = originalText;
                refs.clipboardBtn.style.background = "";
                refs.clipboardBtn.style.color = "";
              }, 1000);
            }).catch(err => {
              console.error('Failed to copy to clipboard:', err);
              // Fallback for older browsers
              const textArea = document.createElement('textarea');
              textArea.value = blockText;
              document.body.appendChild(textArea);
              textArea.select();
              document.execCommand('copy');
              textArea.parentNode.removeChild(textArea);
              
              // Show feedback
              const originalText = refs.clipboardBtn.textContent;
              refs.clipboardBtn.textContent = "✓";
              refs.clipboardBtn.style.background = "var(--green)";
              refs.clipboardBtn.style.color = "white";
              
              setTimeout(() => {
                refs.clipboardBtn.textContent = originalText;
                refs.clipboardBtn.style.background = "";
                refs.clipboardBtn.style.color = "";
              }, 1000);
            });
          }
        }

        function updateRevealButton() {
          const isRevealed = state.revealed.has(state.currentIndex);
          refs.revealBtn.textContent = isRevealed ? "Unreveal" : "Reveal";
        }

        function renderHeader() {
          const q = state.questions[state.currentIndex];
          formattedSource = q.source || "";
          if (refs.removeNumbersFromSources && refs.removeNumbersFromSources.checked) {
            formattedSource = formattedSource.replace(/[0-9]+\.\s/g, "");
          }
          loadHtmlInto(
            refs.source,
            `<span class="dot"></span>${escapeHtml(formattedSource)}`
          );
          refs.progress.textContent = `Question ${state.currentIndex + 1} of ${
            state.questions.length
          }`;
        }

        function renderQuestion() {
          const q = state.questions[state.currentIndex];
          loadHtmlInto(refs.questionText, q.question || "");
        }

        function markChoiceEl(choiceEl, { correct, incorrect }) {
          choiceEl.classList.remove("correct", "incorrect");
          if (correct) choiceEl.classList.add("correct");
          if (incorrect) choiceEl.classList.add("incorrect");
        }

        function isChoiceCorrect(q, choice, resp) {
          if (q.type === "single" || q.type === "multiple")
            return isX(choice.answer);
          if (q.type === "select") {
            const selected = resp.get(choice.originalIndex) || "";
            return String(selected) === String(choice.answer);
          }
          return false;
        }

        function renderChoices() {
          const q = state.questions[state.currentIndex];
          const container = refs.choices;
          container.innerHTML = "";
          ensureResponseFor(state.currentIndex);
          const resp = state.responses.get(state.currentIndex);
          const revealed = state.revealed.has(state.currentIndex);

          if (q.type === "single") {
            q.choices.forEach((choice, idx) => {
              const id = `q${state.currentIndex}_r${idx}`;
              const wrapper = document.createElement("label");
              wrapper.className = "choice";
              wrapper.innerHTML = `
                <input type="radio" name="q_${state.currentIndex}" id="${id}" ${
                resp === idx ? "checked" : ""
              } />
                <div class="label">
                  <div class="text">${choice.text}</div>
                </div>
              `;
              const input = wrapper.querySelector("input");
              input.addEventListener("change", () => {
                state.responses.set(state.currentIndex, idx);
                if (revealed) renderChoices();
                renderControls();
              });
              if (revealed) {
                const correct = isChoiceCorrect(q, choice, resp);
                const incorrect = resp === idx && !correct;
                markChoiceEl(wrapper, { correct, incorrect });
              }
              container.appendChild(wrapper);
            });
          }

          if (q.type === "multiple") {
            q.choices.forEach((choice, idx) => {
              const id = `q${state.currentIndex}_c${idx}`;
              const checked = resp.has(idx);
              const wrapper = document.createElement("label");
              wrapper.className = "choice";
              wrapper.innerHTML = `
                <input type="checkbox" id="${id}" ${checked ? "checked" : ""} />
                <div class="label">
                  <div class="text">${choice.text}</div>
                </div>
              `;
              const input = wrapper.querySelector("input");
              input.addEventListener("change", (e) => {
                if (e.target.checked) resp.add(idx);
                else resp.delete(idx);
                if (revealed) renderChoices();
                renderControls();
              });
              if (revealed) {
                const correct = isChoiceCorrect(q, choice, resp);
                const incorrect = resp.has(idx) && !correct;
                markChoiceEl(wrapper, { correct, incorrect });
              }
              container.appendChild(wrapper);
            });
          }

          if (q.type === "select") {
            // Detect if answers form a 1..N ordering; if so, render drag-and-drop list
            const isNumeric = q.selectOptions.every((v) =>
              /^-?\d+(\.\d+)?$/.test(String(v))
            );
            const expectedCount = q.choices.length;
            const numericSorted = isNumeric
              ? q.selectOptions.map(Number).sort((a, b) => a - b)
              : [];
            const isPermutationOneToN =
              isNumeric &&
              numericSorted.length === expectedCount &&
              numericSorted.every((v, i) => v === i + 1);

            if (isPermutationOneToN) {
              // Build items sorted by current stored order
              const items = q.choices
                .slice()
                .sort(
                  (a, b) =>
                    (resp.get(a.originalIndex) || 0) -
                    (resp.get(b.originalIndex) || 0)
                );

              const buildItem = (choiceObj) => {
                const item = document.createElement("div");
                item.className = "choice dnd-item";
                item.setAttribute("data-oidx", String(choiceObj.originalIndex));
                item.draggable = !revealed;
                item.innerHTML = `
                  <div class="dnd-handle" aria-hidden="true">≡</div>
                  <div class="label" style="flex:1">
                    <div class="text">${choiceObj.text}</div>
                  </div>
                `;
                if (revealed) {
                  const correct = isChoiceCorrect(q, choiceObj, resp);
                  const incorrect = !correct;
                  markChoiceEl(item, { correct, incorrect });
                }
                return item;
              };

              const updateMapFromDom = () => {
                const children = Array.from(
                  container.querySelectorAll(".dnd-item")
                );
                children.forEach((el, idx) => {
                  const oidx = Number(el.getAttribute("data-oidx"));
                  resp.set(oidx, idx + 1);
                });
              };

              const updateIndices = () => {
                const children = Array.from(
                  container.querySelectorAll(".dnd-item")
                );
                children.forEach((el, idx) => {
                  const idxEl = el.querySelector(".dnd-index");
                  if (idxEl) idxEl.textContent = String(idx + 1);
                });
              };

              const getDragAfterElement = (parent, y) => {
                const draggableElements = [
                  ...parent.querySelectorAll(".dnd-item:not(.dragging)"),
                ];
                return draggableElements.reduce(
                  (closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;
                    if (offset < 0 && offset > closest.offset) {
                      return { offset, element: child };
                    } else {
                      return closest;
                    }
                  },
                  { offset: Number.NEGATIVE_INFINITY, element: null }
                ).element;
              };

              // FLIP helpers to animate siblings when order changes
              const capturePositions = () => {
                const map = new Map();
                container.querySelectorAll(".dnd-item").forEach((el) => {
                  map.set(el, el.getBoundingClientRect().top);
                });
                return map;
              };

              const playReorderAnimation = (prevPositions, excludeEl) => {
                const children = Array.from(
                  container.querySelectorAll(".dnd-item")
                );
                const toAnimate = [];
                children.forEach((el) => {
                  if (el === excludeEl) return;
                  const prevTop = prevPositions.get(el);
                  if (prevTop == null) return;
                  const newTop = el.getBoundingClientRect().top;
                  const delta = prevTop - newTop;
                  if (delta !== 0) {
                    // Ensure the initial transform is applied without transition
                    const prevTransition = el.style.transition;
                    el.style.transition = "none";
                    el.style.transform = `translateY(${delta}px)`;
                    // Force reflow so the browser applies the transform immediately
                    void el.offsetHeight;
                    // Restore transition so the following change animates
                    el.style.transition = prevTransition;
                    toAnimate.push(el);
                  }
                });
                if (toAnimate.length) {
                  // Next frame: return to identity to trigger transition
                  requestAnimationFrame(() => {
                    toAnimate.forEach((el) => {
                      el.style.transform = "";
                    });
                  });
                }
              };

              // Render items
              items.forEach((c) => container.appendChild(buildItem(c)));

              if (!revealed) {
                let currentDragImage = null;
                let isDragging = false;
                let startY = 0;
                let currentY = 0;
                let draggedElement = null;
                let longPressTimer = null;
                let touchStartTime = 0;
                let isTouchDevice = false;
                let initialElementTop = 0;
                let initialElementLeft = 0;

                // Prevent text selection during drag
                const preventTextSelection = (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                };

                // Touch event handlers for mobile drag and drop
                const handleTouchStart = (e) => {
                  const target = e.target.closest(".dnd-item");
                  if (!target) return;
                  
                  isTouchDevice = true;
                  touchStartTime = Date.now();
                  startY = e.touches[0].clientY;
                  currentY = startY;
                  draggedElement = target;
                  
                  // Store initial position
                  const rect = target.getBoundingClientRect();
                  initialElementTop = rect.top;
                  initialElementLeft = rect.left;
                  
                  // Start long press timer
                  longPressTimer = setTimeout(() => {
                    if (draggedElement && !isDragging) {
                      isDragging = true;
                      draggedElement.classList.add("dragging");
                      
                      // Create drag image
                      const clone = draggedElement.cloneNode(true);
                      clone.style.position = "fixed";
                      clone.style.pointerEvents = "none";
                      clone.style.top = "-9999px";
                      clone.style.left = "-9999px";
                      clone.style.width = draggedElement.offsetWidth + "px";
                      clone.style.height = draggedElement.offsetHeight + "px";
                      clone.style.opacity = "0.8";
                      clone.style.boxShadow = "0 8px 24px rgba(0,0,0,0.15)";
                      clone.style.zIndex = "9999";
                      document.body.appendChild(clone);
                      currentDragImage = clone;
                      
                      // Prevent text selection
                      document.body.style.userSelect = "none";
                      document.body.style.webkitUserSelect = "none";
                      document.body.style.mozUserSelect = "none";
                      document.body.style.msUserSelect = "none";
                    }
                  }, 300); // 300ms long press threshold
                };

                const handleTouchMove = (e) => {
                  if (!isDragging || !draggedElement) return;
                  
                  e.preventDefault();
                  currentY = e.touches[0].clientY;
                  
                  // Move drag image to follow finger from initial position
                  if (currentDragImage) {
                    const offsetY = currentY - startY;
                    currentDragImage.style.top = (initialElementTop + offsetY) + "px";
                    currentDragImage.style.left = initialElementLeft + "px";
                  }
                  
                  // Update position in list
                  const prevPositions = capturePositions();
                  const afterElement = getDragAfterElement(container, currentY);
                  if (afterElement == null) {
                    container.appendChild(draggedElement);
                  } else {
                    container.insertBefore(draggedElement, afterElement);
                  }
                  playReorderAnimation(prevPositions, draggedElement);
                };

                const handleTouchEnd = (e) => {
                  if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                  }
                  
                  if (isDragging && draggedElement) {
                    isDragging = false;
                    draggedElement.classList.remove("dragging");
                    
                    // Clean up drag image
                    if (currentDragImage && currentDragImage.parentNode) {
                      currentDragImage.parentNode.removeChild(currentDragImage);
                      currentDragImage = null;
                    }
                    
                    // Restore text selection
                    document.body.style.userSelect = "";
                    document.body.style.webkitUserSelect = "";
                    document.body.style.mozUserSelect = "";
                    document.body.style.msUserSelect = "";
                    
                    // Update state
                    updateMapFromDom();
                    renderControls();
                  }
                  
                  draggedElement = null;
                  startY = 0;
                  currentY = 0;
                  isTouchDevice = false;
                  initialElementTop = 0;
                  initialElementLeft = 0;
                };

                const handleTouchCancel = () => {
                  if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                  }
                  
                  if (isDragging && draggedElement) {
                    isDragging = false;
                    draggedElement.classList.remove("dragging");
                    
                    if (currentDragImage && currentDragImage.parentNode) {
                      currentDragImage.parentNode.removeChild(currentDragImage);
                      currentDragImage = null;
                    }
                    
                    document.body.style.userSelect = "";
                    document.body.style.webkitUserSelect = "";
                    document.body.style.mozUserSelect = "";
                    document.body.style.msUserSelect = "";
                  }
                  
                  draggedElement = null;
                  startY = 0;
                  currentY = 0;
                  isTouchDevice = false;
                  initialElementTop = 0;
                  initialElementLeft = 0;
                };

                // Add touch event listeners to each item
                container.querySelectorAll(".dnd-item").forEach(item => {
                  item.addEventListener("touchstart", handleTouchStart, { passive: false });
                  item.addEventListener("touchmove", handleTouchMove, { passive: false });
                  item.addEventListener("touchend", handleTouchEnd, { passive: false });
                  item.addEventListener("touchcancel", handleTouchCancel, { passive: false });
                  
                  // Prevent text selection on long press
                  item.addEventListener("selectstart", preventTextSelection);
                  item.addEventListener("dragstart", preventTextSelection);
                });

                // Mouse drag and drop for desktop (only when not on touch device)
                const handleMouseDown = (e) => {
                  if (isTouchDevice) return; // Skip if we're on a touch device
                  
                  const target = e.target && e.target.closest(".dnd-item");
                  if (!target) return;
                  
                  draggedElement = target;
                  startY = e.clientY;
                  currentY = startY;
                  
                  // Store initial position
                  const rect = target.getBoundingClientRect();
                  initialElementTop = rect.top;
                  initialElementLeft = rect.left;
                };

                const handleMouseMove = (e) => {
                  if (!draggedElement || isTouchDevice) return;
                  
                  if (!isDragging) {
                    isDragging = true;
                    draggedElement.classList.add("dragging");
                    
                    // Create drag image
                    const clone = draggedElement.cloneNode(true);
                    clone.style.position = "fixed";
                    clone.style.pointerEvents = "none";
                    clone.style.top = "-9999px";
                    clone.style.left = "-9999px";
                    clone.style.width = draggedElement.offsetWidth + "px";
                    clone.style.height = draggedElement.offsetHeight + "px";
                    clone.style.opacity = "0.8";
                    clone.style.boxShadow = "0 8px 24px rgba(0,0,0,0.15)";
                    clone.style.zIndex = "9999";
                    document.body.appendChild(clone);
                    currentDragImage = clone;
                  }
                  
                  currentY = e.clientY;
                  
                  // Move drag image to follow mouse from initial position
                  if (currentDragImage) {
                    const offsetY = currentY - startY;
                    currentDragImage.style.top = (initialElementTop + offsetY) + "px";
                    currentDragImage.style.left = initialElementLeft + "px";
                  }
                  
                  // Update position in list
                  const prevPositions = capturePositions();
                  const afterElement = getDragAfterElement(container, currentY);
                  if (afterElement == null) {
                    container.appendChild(draggedElement);
                  } else {
                    container.insertBefore(draggedElement, afterElement);
                  }
                  playReorderAnimation(prevPositions, draggedElement);
                };

                const handleMouseUp = () => {
                  if (!draggedElement || isTouchDevice) return;
                  
                  if (isDragging) {
                    isDragging = false;
                    draggedElement.classList.remove("dragging");
                    
                    // Clean up drag image
                    if (currentDragImage && currentDragImage.parentNode) {
                      currentDragImage.parentNode.removeChild(currentDragImage);
                      currentDragImage = null;
                    }
                    
                    // Update state
                    updateMapFromDom();
                    renderControls();
                  }
                  
                  draggedElement = null;
                  startY = 0;
                  currentY = 0;
                  initialElementTop = 0;
                  initialElementLeft = 0;
                };

                // Add mouse event listeners to container
                container.addEventListener("mousedown", handleMouseDown);
                document.addEventListener("mousemove", handleMouseMove);
                document.addEventListener("mouseup", handleMouseUp);
              }
            } else {
              // Fallback: original dropdown UI
              q.choices.forEach((choice) => {
                const wrapper = document.createElement("div");
                wrapper.className = "choice";
                const current = resp.get(choice.originalIndex) || "";
                const optionsHtml = [
                  '<option value="">Select…</option>',
                  ...q.selectOptions.map(
                    (opt) =>
                      `<option value="${String(opt)}" ${
                        String(current) === String(opt) ? "selected" : ""
                      }>${String(opt)}</option>`
                  ),
                ].join("");
                wrapper.innerHTML = `
                  <div class="label" style="display:flex; gap:12px; align-items:flex-start; width:100%">
                    <div class="text" style="flex:1">${choice.text}</div>
                    <div>
                      <select aria-label="Select answer">
                        ${optionsHtml}
                      </select>
                    </div>
                  </div>
                `;
                const select = wrapper.querySelector("select");
                select.addEventListener("change", (e) => {
                  const value = e.target.value;
                  resp.set(choice.originalIndex, value);
                  if (revealed) renderChoices();
                  renderControls();
                });
                if (revealed) {
                  const correct = isChoiceCorrect(q, choice, resp);
                  const incorrect =
                    !correct && (resp.get(choice.originalIndex) || "") !== "";
                  markChoiceEl(wrapper, { correct, incorrect });
                }
                container.appendChild(wrapper);
              });
            }
          }
        }

        function renderControls() {
          refs.prevBtn.disabled = state.currentIndex === 0;
          // Never disable next on the last question; turn it into "Finish"
          const isLast = state.currentIndex === state.questions.length - 1;
          refs.nextBtn.disabled = isLast && countAnsweredQuestions() === 0;
          refs.nextBtn.textContent = isLast ? "Finish" : "Next";
          updateRevealButton();
        }

        function handleNumericChoiceKey(key) {
          const quizVisible =
            refs.quiz && !refs.quiz.classList.contains("hidden");
          if (!quizVisible) return;
          // Map '1'..'9' -> 0..8, '0' -> 9
          if (!/^\d$/.test(key)) return;
          const number = Number(key);
          const targetIdx = number === 0 ? 9 : number - 1;
          const q = state.questions[state.currentIndex];
          if (!q || targetIdx < 0 || targetIdx >= q.choices.length) return;
          ensureResponseFor(state.currentIndex);
          const revealed = state.revealed.has(state.currentIndex);
          if (q.type === "single") {
            const current = state.responses.get(state.currentIndex);
            if (current === targetIdx) {
              // Toggle off if same radio pressed
              state.responses.set(state.currentIndex, -1);
              if (revealed) renderChoices();
              renderControls();
              return;
            }
            const radios = refs.choices.querySelectorAll('input[type="radio"]');
            if (radios && radios[targetIdx]) {
              radios[targetIdx].click();
            } else {
              // Fallback: set state and re-render
              state.responses.set(state.currentIndex, targetIdx);
              if (revealed) renderChoices();
              renderControls();
            }
          } else if (q.type === "multiple") {
            const checkboxes = refs.choices.querySelectorAll(
              'input[type="checkbox"]'
            );
            if (checkboxes && checkboxes[targetIdx]) {
              // Click to toggle and trigger existing listeners
              checkboxes[targetIdx].click();
            } else {
              // Fallback: toggle state directly
              const resp = state.responses.get(state.currentIndex);
              if (resp instanceof Set) {
                if (resp.has(targetIdx)) resp.delete(targetIdx);
                else resp.add(targetIdx);
                if (revealed) renderChoices();
                renderControls();
              }
            }
          }
        }

        function render() {
          renderHeader();
          renderQuestion();
          renderChoices();
          renderControls();
        }

        function startQuizFromText(text) {
          const spinner = $("#spinner");
          const settings = $("#settings");
          const uploader = $("#uploader");
          spinner.classList.remove("hidden");
          settings.classList.add("hidden");
          try {
            const rawQuestions = parseQuestionsFile(text);
            if (!rawQuestions || !rawQuestions.length) {
              throw new Error("No questions found in file");
            }
            // Store raw questions for later processing based on settings
            state.rawQuestions = rawQuestions;
            if (uploader) uploader.classList.add("hidden");
            settings.classList.remove("hidden");
          } catch (err) {
            console.error(err);
            const statusEl = $("#uploadStatus");
            if (statusEl)
              statusEl.textContent =
                "Failed to load file. " +
                (err && err.message ? err.message : "");
          } finally {
            spinner.classList.add("hidden");
          }
        }

        function startQuizWithSettings() {
          const shouldShuffle = refs.shuffleQuestions.checked;
          state.questions = buildQuizData(state.rawQuestions, shouldShuffle);
          state.currentIndex = 0;
          state.responses = new Map();
          state.revealed = new Set();
          ensureResponseFor(0);
          
          refs.settings.classList.add("hidden");
          refs.quiz.classList.remove("hidden");
          render();
        }

        function getQuestionCorrectness(q, resp) {
          if (q.type === "single") {
            if (typeof resp !== "number" || resp < 0) return false;
            const choice = q.choices[resp];
            return !!choice && isX(choice.answer);
          }
          if (q.type === "multiple") {
            const selected = resp instanceof Set ? resp : new Set();
            const correctIdx = new Set(
              q.choices
                .map((c, i) => (isX(c.answer) ? i : -1))
                .filter((i) => i !== -1)
            );
            if (selected.size !== correctIdx.size) return false;
            for (const i of selected) {
              if (!correctIdx.has(i)) return false;
            }
            return true;
          }
          if (q.type === "select") {
            const map = resp instanceof Map ? resp : new Map();
            // All rows must match their expected answer
            return q.choices.every(
              (c) => String(map.get(c.originalIndex) || "") === String(c.answer)
            );
          }
          return false;
        }

        function computeResults() {
          let correctCount = 0;
          let answeredCount = 0;
          let skipped = 0;
          /** @type {{questionIndex:number, question:any, type:string, details:any}[]} */
          const wrong = [];
          state.questions.forEach((q, idx) => {
            ensureResponseFor(idx);
            const resp = state.responses.get(idx);
            const answered = isQuestionAnswered(q, resp);
            if (!answered) {
              skipped += 1;
              return;
            } // skip entirely
            answeredCount += 1;
            const isCorrect = getQuestionCorrectness(q, resp);
            if (isCorrect) {
              correctCount += 1;
            } else {
              // Build details for review (exclude skipped)
              if (q.type === "single") {
                const selectedIdx = typeof resp === "number" ? resp : -1;
                const your =
                  selectedIdx >= 0 ? q.choices[selectedIdx]?.text || "" : "";
                const correct =
                  q.choices.find((c) => isX(c.answer))?.text || "";
                wrong.push({
                  questionIndex: idx,
                  question: q.question,
                  type: q.type,
                  details: { your, correct },
                });
              } else if (q.type === "multiple") {
                const selected = resp instanceof Set ? Array.from(resp) : [];
                const your = selected
                  .map((i) => q.choices[i]?.text || "")
                  .join("<br/>");
                const correct = q.choices
                  .map((c, i) => (isX(c.answer) ? q.choices[i].text : null))
                  .filter(Boolean)
                  .join("<br/>");
                wrong.push({
                  questionIndex: idx,
                  question: q.question,
                  type: q.type,
                  details: { your, correct },
                });
              } else if (q.type === "select") {
                const map = resp instanceof Map ? resp : new Map();
                const rows = q.choices.map((c) => ({
                  text: c.text,
                  your: String(map.get(c.originalIndex) || ""),
                  correct: String(c.answer),
                }));
                wrong.push({
                  questionIndex: idx,
                  question: q.question,
                  type: q.type,
                  details: { rows },
                });
              }
            }
          });
          const total = answeredCount;
          const percent =
            total > 0 ? Math.round((correctCount / total) * 100) : 0;
          return { correctCount, total, percent, wrong, skipped };
        }

        function buildResultsHtml(results) {
          const { correctCount, total, percent, wrong, skipped } = results;
          const header = `<div class="card-header"><div class="source"><span class="dot"></span>Results</div><div class="progress">Score: ${correctCount}/${total} (${percent}%)</div></div>`;

          const reviewItems = wrong
            .map((w, i) => {
              if (w.type === "select") {
                const rowsHtml = w.details.rows
                  .slice()
                  .sort((a, b) => {
                    // Try to sort numerically if possible, else lexically
                    const aNum = parseFloat(a.correct);
                    const bNum = parseFloat(b.correct);
                    if (!isNaN(aNum) && !isNaN(bNum)) {
                      return aNum - bNum;
                    }
                    return String(a.correct).localeCompare(String(b.correct));
                  })
                  .map(
                    (r) => `
                  <tr>
                    <td style="vertical-align:top; padding:6px 8px 6px 0; width:55%">${
                      r.text
                    }</td>
                    <td style="vertical-align:top; padding:6px 8px; color: var(--red)">${escapeHtml(
                      r.your || "(no selection)"
                    )}</td>
                    <td style="vertical-align:top; padding:6px 0; color: var(--green)">${escapeHtml(
                      r.correct
                    )}</td>
                  </tr>
                `
                  )
                  .join("");
                return `
                <div class="card-body" style="border-top:1px solid var(--border)">
                  <div class="question-text" style="margin-bottom:8px"><b>Question ${
                    w.questionIndex + 1
                  }:</b><br/>${w.question}</div>
                  <div style="overflow:auto">
                    <table style="width:100%; border-collapse:collapse; font-size:14px">
                      <thead>
                        <tr>
                          <th style="text-align:left; padding:6px 8px 6px 0; color:var(--muted); font-weight:600">Choice</th>
                          <th style="text-align:left; padding:6px 8px; color:var(--muted); font-weight:600">Your answer</th>
                          <th style="text-align:left; padding:6px 0; color:var(--muted); font-weight:600">Correct</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${rowsHtml}
                      </tbody>
                    </table>
                  </div>
                </div>`;
              }
              return `
              <div class="card-body" style="border-top:1px solid var(--border)">
                <div class="question-text" style="margin-bottom:8px"><b>Question ${
                  w.questionIndex + 1
                }:</b><br/>${w.question}</div>
                <div style="display:grid; gap:4px; font-size:14px">
                  <div><b>Your answer:</b><br/>${w.details.your}</div>
                  <div><b>Correct answer:</b><br/>${w.details.correct}</div>
                </div>
              </div>`;
            })
            .join("");

          const bodyTop = `
              <div class="card-body">
                <div class="question-text" style="margin:0">
                  Your score: <b>${percent}%</b> (${correctCount} / ${total}).
                  <br>
                  <span style="color:var(--muted); font-size:13px">
                    ${skipped} question${skipped === 1 ? "" : "s"} skipped
                  </span>
                </div>
              </div>`;

          const controls = `
              <div class="controls">
                <div class="left-controls">
                  <button id="restartBtn" class="secondary" type="button">Restart</button>
                </div>
                <div class="right-controls">
                  <div class="status"></div>
                  <button id="reviewToggleBtn" type="button">${
                    wrong.length ? "Show review" : "Done"
                  }</button>
                </div>
              </div>`;

          const reviewBlock = wrong.length ? reviewItems : ``;
          return header + bodyTop + reviewBlock + controls;
        }

        function showResults() {
          const quiz = $("#quiz");
          const resultsEl = $("#results");
          const results = computeResults();
          resultsEl.innerHTML = buildResultsHtml(results);
          quiz.classList.add("hidden");
          resultsEl.classList.remove("hidden");

          // Wire buttons
          const restartBtn = document.getElementById("restartBtn");
          if (restartBtn) {
            restartBtn.addEventListener("click", () => {
              // Reload the page to fully restart and reshuffle as on a fresh load
              window.location.reload();
            });
          }
          const reviewToggleBtn = document.getElementById("reviewToggleBtn");
          if (reviewToggleBtn) {
            if (reviewToggleBtn.textContent === "Done") {
              reviewToggleBtn.addEventListener("click", () => {
                // Same as restart for simplicity
                if (restartBtn) restartBtn.click();
              });
            } else {
              let showing = true;
              reviewToggleBtn.addEventListener("click", () => {
                showing = !showing;
                // Toggle visibility of review bodies (all but first body which is summary)
                resultsEl.querySelectorAll(".card-body").forEach((el, idx) => {
                  if (idx === 0) return; // keep summary
                  el.classList.toggle("hidden", !showing);
                });
                reviewToggleBtn.textContent = showing
                  ? "Hide review"
                  : "Show review";
              });
              // Start with review shown
              reviewToggleBtn.textContent = "Hide review";
            }
          }
        }

        function init() {
          refs.source = $("#source");
          refs.progress = $("#progress");
          refs.questionText = $("#questionText");
          refs.choices = $("#choices");
          refs.prevBtn = $("#prevBtn");
          refs.nextBtn = $("#nextBtn");
          refs.revealBtn = $("#revealBtn");
          refs.clipboardBtn = $("#clipboardBtn");
          refs.status = $("#status");
          refs.results = $("#results");
          refs.quiz = $("#quiz");
          refs.fileInput = $("#fileInput");
          refs.dropzone = $("#dropzone");
          refs.chooseBtn = $("#chooseBtn");
          refs.uploadStatus = $("#uploadStatus");
          refs.uploader = $("#uploader");
          refs.spinner = $("#spinner");
          refs.urlInput = $("#urlInput");
          refs.urlLoadBtn = $("#urlLoadBtn");
          refs.settings = $("#settings");
          refs.shuffleQuestions = $("#shuffleQuestions");
          refs.removeNumbersFromSources = $("#removeNumbersFromSources");
          refs.backToUploadBtn = $("#backToUploadBtn");
          refs.startQuizBtn = $("#startQuizBtn");

          refs.prevBtn.addEventListener("click", onPrev);
          refs.nextBtn.addEventListener("click", onNext);
          refs.revealBtn.addEventListener("click", onReveal);
          refs.clipboardBtn.addEventListener("click", onCopyToClipboard);

          // Settings panel event listeners
          refs.backToUploadBtn.addEventListener("click", () => {
            refs.settings.classList.add("hidden");
            refs.uploader.classList.remove("hidden");
          });
          
          refs.startQuizBtn.addEventListener("click", () => {
            startQuizWithSettings();
          });

          // Hide spinner initially; show uploader by default
          if (refs.spinner) refs.spinner.classList.add("hidden");
          if (refs.uploader) refs.uploader.classList.remove("hidden");

          function loadFile(file) {
            if (!file) return;
            if (refs.uploadStatus)
              refs.uploadStatus.textContent = "Loading " + file.name + "…";
            refs.spinner.classList.remove("hidden");
            const reader = new FileReader();
            reader.onload = () =>
              startQuizFromText(String(reader.result || ""));
            reader.onerror = () => {
              refs.spinner.classList.add("hidden");
              if (refs.uploadStatus)
                refs.uploadStatus.textContent = "Failed to read file.";
            };
            reader.readAsText(file);
          }

          async function loadFromUrl(inputUrl) {
            const raw = String(inputUrl || "").trim();
            const url = raw || DEFAULT_URL;
            try {
              refs.uploader.classList.add("hidden");
              refs.spinner.classList.remove("hidden");
              const response = await fetch(url, { cache: "no-cache" });
              if (!response.ok)
                throw new Error(
                  "HTTP " + response.status + " " + response.statusText
                );
              const text = await response.text();
              startQuizFromText(String(text || ""));
              if (refs.uploadStatus) refs.uploadStatus.textContent = "";
            } catch (err) {
              refs.spinner.classList.add("hidden");
              if (refs.uploadStatus)
                refs.uploadStatus.textContent =
                  "Failed to fetch URL. " +
                  (err && err.message ? err.message : "");
            }
          }

          if (refs.fileInput) {
            refs.fileInput.addEventListener("change", () => {
              if (refs.uploadStatus) refs.uploadStatus.textContent = "";
              const file = refs.fileInput.files && refs.fileInput.files[0];
              if (file) loadFile(file);
            });
          }
          if (refs.dropzone) {
            const openPicker = () => refs.fileInput && refs.fileInput.click();
            refs.dropzone.addEventListener("click", openPicker);
            // Mobile touch events for better mobile experience
            refs.dropzone.addEventListener("touchstart", (e) => {
              e.preventDefault();
              refs.dropzone.classList.add("hover");
            });
            refs.dropzone.addEventListener("touchend", (e) => {
              e.preventDefault();
              refs.dropzone.classList.remove("hover");
              // Small delay to show the hover effect briefly
              setTimeout(() => {
                openPicker();
              }, 150);
            });
            refs.dropzone.addEventListener("touchcancel", () => {
              refs.dropzone.classList.remove("hover");
            });
            refs.dropzone.addEventListener("keydown", (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                openPicker();
              }
            });
            refs.dropzone.addEventListener("dragover", (e) => {
              e.preventDefault();
              refs.dropzone.classList.add("hover");
            });
            refs.dropzone.addEventListener("dragleave", () =>
              refs.dropzone.classList.remove("hover")
            );
            refs.dropzone.addEventListener("drop", (e) => {
              e.preventDefault();
              refs.dropzone.classList.remove("hover");
              const file =
                e.dataTransfer &&
                e.dataTransfer.files &&
                e.dataTransfer.files[0];
              if (file) loadFile(file);
            });
          }

          if (refs.urlLoadBtn) {
            refs.urlLoadBtn.addEventListener("click", () => {
              const val = refs.urlInput && refs.urlInput.value;
              loadFromUrl(val);
            });
          }
          if (refs.urlInput) {
            refs.urlInput.addEventListener("keydown", (e) => {
              if (e.key === "Enter") {
                e.preventDefault();
                const val = refs.urlInput && refs.urlInput.value;
                loadFromUrl(val);
              }
            });
          }

          // Keyboard navigation: Left = Previous, Right/Space = Next
          document.addEventListener("keydown", (e) => {
            // Only when quiz is visible
            const quizVisible =
              refs.quiz && !refs.quiz.classList.contains("hidden");
            if (!quizVisible) return;
            // Ignore when typing in form fields or using modifiers
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            const target = e.target || document.activeElement;
            const tag = (
              target && target.tagName ? target.tagName : ""
            ).toLowerCase();
            const isTextEntryEl =
              (target && target.isContentEditable) ||
              tag === "select" ||
              tag === "textarea" ||
              tag === "button";
            // Disable native arrow navigation on input elements (e.g., radio/checkbox)
            if (
              tag === "input" &&
              (e.key === "ArrowLeft" ||
                e.key === "ArrowRight" ||
                e.key === "ArrowUp" ||
                e.key === "ArrowDown")
            ) {
              e.preventDefault();
            }
            if (isTextEntryEl) return;

            // Number keys -> toggle/select answers
            if (/^\d$/.test(e.key)) {
              e.preventDefault();
              handleNumericChoiceKey(e.key);
              return;
            }

            if (e.key === "ArrowLeft") {
              e.preventDefault();
              onPrev();
            } else if (e.key === "ArrowRight") {
              e.preventDefault();
              onNext();
            } else if (e.key === " " || e.key === "Spacebar") {
              e.preventDefault();
              onReveal();
            }
          });
        }

        window.addEventListener("DOMContentLoaded", init);
      })();
    </script>
  </head>

  <body>
    <div class="app">

      <div id="spinner" class="card spinner-wrap hidden">
        <div class="spinner" aria-hidden="true"></div>
        <span class="sr-only">Loading…</span>
      </div>

      <div id="uploader" class="card">
        <div class="card-header">
          <div class="source">
            <span class="dot"></span>
          </div>
          <div class="progress"></div>
        </div>
        <div class="card-body">
          <div
            id="dropzone"
            class="dropzone"
            tabindex="0"
            role="button"
            aria-label="Choose a questions file to start the quiz"
          >
            <div class="dz-icon">↑</div>
            <div class="dz-title">Drag & drop your question file here</div>
          </div>
          <input
            id="fileInput"
            type="file"
            accept=".quiz,.txt,.*"
            style="
              position: absolute;
              width: 1px;
              height: 1px;
              padding: 0;
              margin: -1px;
              overflow: hidden;
              clip: rect(0, 0, 0, 0);
              border: 0;
            "
          />
          <div class="or-sep">or</div>
          <div class="url-loader">
            <input
              id="urlInput"
              class="url-input"
              type="url"
              inputmode="url"
              placeholder="https://quiz.qot.app/example"
              aria-label="Quiz file URL"
            />
            <button id="urlLoadBtn" type="button">Load</button>
          </div>
          <div id="uploadStatus" class="status" style="margin-top: 12px"></div>
        </div>
        <div class="controls" style="justify-content: flex-end">
          <div class="right-controls">
            <div class="status"></div>
          </div>
        </div>
      </div>

      <div id="quiz" class="card hidden">
        <div class="card-header">
          <div id="source" class="source">
            <span class="dot"></span>Loading…
          </div>
          <div id="progress" class="progress">Question 0 of 0</div>
        </div>
        <div class="card-body">
          <div id="questionText" class="question-text"></div>
          <div id="choices" class="choices"></div>
        </div>
        <div class="controls">
          <div class="left-controls">
            <button id="clipboardBtn" class="secondary" type="button" title="Copy question text to clipboard">
              📋
            </button>
            <button id="prevBtn" class="secondary" type="button">
              Previous
            </button>
            <button id="revealBtn" class="secondary" type="button">
              Reveal answers
            </button>
          </div>
          <div class="right-controls">
            <div id="status" class="status"></div>
            <button id="nextBtn" type="button">Next</button>
          </div>
        </div>
      </div>

      <div id="settings" class="card hidden">
        <div class="card-header">
          <div class="source">
            <span class="dot"></span>Quiz Settings
          </div>
        </div>
        <div class="card-body">
          <div style="display: grid; gap: 16px;">
            <label class="setting-item" style="display: flex; align-items: flex-start; gap: 12px; cursor: pointer;">
              <input type="checkbox" id="shuffleQuestions" checked style="margin-top: 2px;">
              <div style="flex: 1;">
                <div style="font-weight: 600; margin-bottom: 4px;">Randomize the order of questions</div>
              </div>
            </label>
            <label class="setting-item" style="display: flex; align-items: flex-start; gap: 12px; cursor: pointer;">
              <input type="checkbox" id="removeNumbersFromSources" checked style="margin-top: 2px;">
              <div style="flex: 1;">
                <div style="font-weight: 600; margin-bottom: 4px;">Clean up source display</div>
              </div>
            </label>
          </div>
        </div>
        <div class="controls">
          <div class="left-controls">
            <button id="backToUploadBtn" class="secondary" type="button">←</button>
          </div>
          <div class="right-controls">
            <button id="startQuizBtn" type="button">Start</button>
          </div>
        </div>
      </div>
      <div id="results" class="card hidden"></div>
      <a
        href="https://github.com/DomJob/QuizApp"
        target="_blank"
        class="github-link"
        aria-label="View on GitHub"
      >
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path
            d="M12 2C6.477 2 2 6.477 2 12c0 4.42 2.865 8.13 6.839 9.458.5.092.682-.217.682-.48 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.465-1.11-1.465-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.27.098-2.647 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.026 2.747-1.026.546 1.377.202 2.394.1 2.647.64.7 1.028 1.595 1.028 2.688 0 3.848-2.335 4.708-4.554 4.955.354.306.673.917.673 1.857 0 1.336-.012 2.415-.012 2.747 0 .267.18.586.688.48C19.135 20.137 22 16.427 22 12c0-5.523-4.477-10-10-10z"
          />
        </svg>
      </a>
    </div>
  </body>
</html>
