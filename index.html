<!DOCTYPE html>
<html lang="en">
  <head>
    <script>
      // Quiz will be loaded from a user-uploaded file

      function escapeHtml(text) {
        return String(text)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function parseMarkdown(input) {
        if (!input) return "";

        let text = String(input).replace(/\r\n/g, "\n");

        // Extract fenced code blocks to placeholders to avoid formatting inside them
        const codeBlocks = [];
        text = text.replace(
          /```(\w+)?\s*([\s\S]*?)```/g,
          (match, lang, code) => {
            const placeholder = `__CODEBLOCK_${codeBlocks.length}__`;
            codeBlocks.push({ lang: lang || "", code: code });
            return placeholder;
          }
        );

        // Inline code
        text = text.replace(
          /`([^`]+)`/g,
          (m, code) => `<code>${escapeHtml(code)}</code>`
        );

        // Bold
        text = text.replace(/\*\*(.+?)\*\*/g, "<b>$1</b>");

        // Italic
        text = text.replace(/\*(.+?)\*/g, "<i>$1</i>");

        // Newlines -> <br/>
        text = text.replace(/\n\n/g, "<br/><br />").replace(/\n/g, "<br/>");

        // Restore code blocks
        text = text.replace(/__CODEBLOCK_(\d+)__/g, (m, idxStr) => {
          const idx = Number(idxStr);
          const blk = codeBlocks[idx];
          const escaped = escapeHtml(String(blk.code).replace(/\r\n/g, "\n"));
          const langClass = blk.lang ? ` class="language-${blk.lang}"` : "";
          return `<pre><code${langClass}>${escaped}</code></pre>`;
        });

        return text;
      }

      function parseQuestionBlock(block) {
        // Preserve blank lines; strip only trailing carriage returns
        const lines = block
          .trim()
          .split("\n")
          .map((l) => l.replace(/\r$/, ""));
        let source = "";
        let question = "";
        let choices = [];
        let i = 0;

        // Find source
        if (lines[i] && lines[i].trim().startsWith("Source:")) {
          source = lines[i].trim().replace(/^Source:\s*/, "");
          i++;
        }

        // Find question
        let questionLines = [];
        // Find the line that starts with "Question:"
        while (i < lines.length && !lines[i].trim().startsWith("Question:")) {
          i++;
        }
        if (i < lines.length && lines[i].trim().startsWith("Question:")) {
          // Remove "Question:" and start collecting question lines (preserving indentation and blanks)
          questionLines.push(lines[i].replace(/^(\s*)Question:\s*/, "$1"));
          i++;
          // Collect all lines until we hit a choice line (starts with [)
          while (i < lines.length && !lines[i].trim().match(/^\[[^\]]*\]/)) {
            questionLines.push(lines[i]);
            i++;
          }
        }
        question = questionLines.join("\n").replace(/^\n+|\n+$/g, "");

        // Parse choices
        while (i < lines.length) {
          // Choices start with [<answer>] <text>
          const match = lines[i].match(/^\s*\[([^\]]*)\]\s?(.*)$/);
          if (match) {
            let answer = match[1].trim();
            let text = match[2] || "";
            // Collect multiline choice text
            i++;
            while (i < lines.length && !lines[i].trim().match(/^\[[^\]]*\]/)) {
              text += "\n" + lines[i];
              i++;
            }
            choices.push({
              text: text.replace(/^\n+|\n+$/g, ""),
              answer: answer,
            });
          } else {
            i++;
          }
        }

        return {
          source,
          question: parseMarkdown(question),
          choices: choices.map((c) => ({
            text: parseMarkdown(c.text),
            answer: c.answer,
          })),
        };
      }

      function parseQuestionsFile(content) {
        return content
          .replace(/\r\n/g, "\n")
          .trim()
          .split("-----")
          .filter((block) => block.trim() !== "")
          .map(parseQuestionBlock);
      }
    </script>
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ“‹</text></svg>"
    />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Practice Quiz</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #f8fafc;
        /* slate-50 */
        --panel: #ffffff;
        --panel-2: #ffffff;
        --text: #111827;
        /* slate-900 */
        --muted: #6b7280;
        /* slate-500 */
        --accent: #4f46e5;
        /* indigo-600 */
        --accent-2: #06b6d4;
        /* cyan-500 */
        --green: #16a34a;
        --red: #dc2626;
        --yellow: #ca8a04;
        --border: #e5e7eb;
        /* gray-200 */
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: var(--text);
        background: radial-gradient(
            1200px 800px at 0% -20%,
            rgba(79, 70, 229, 0.06),
            rgba(6, 182, 212, 0.04) 30%,
            transparent 60%
          ),
          radial-gradient(
            800px 600px at 100% 120%,
            rgba(79, 70, 229, 0.06),
            rgba(6, 182, 212, 0.04) 30%,
            transparent 60%
          ),
          var(--bg);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 24px;
      }

      .app {
        width: 100%;
        max-width: 960px;
      }

      .card {
        background: linear-gradient(180deg, var(--panel), var(--panel-2));
        border: 1px solid var(--border);
        border-radius: 16px;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.08),
          0 1px 0 rgba(255, 255, 255, 0.6) inset;
        overflow: hidden;
      }

      .card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 18px 20px;
        border-bottom: 1px solid var(--border);
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0.02),
          rgba(0, 0, 0, 0)
        );
      }

      .source {
        font-size: 14px;
        color: var(--muted);
        display: flex;
        gap: 8px;
        align-items: center;
        align-self: flex-start;
        /* ensure upper-left alignment */
      }

      .source .dot {
        width: 6px;
        height: 6px;
        border-radius: 3px;
        background: var(--accent-2);
        box-shadow: 0 0 14px var(--accent-2);
      }

      .progress {
        font-size: 14px;
        color: var(--muted);
      }

      .card-body {
        padding: 20px;
      }

      .question-text {
        font-size: 18px;
        line-height: 1.6;
        margin: 4px 0 16px 0;
      }

      .choices {
        display: grid;
        gap: 10px;
      }

      .choice {
        border: 1px solid var(--border);
        background: #ffffff;
        padding: 12px 14px;
        border-radius: 12px;
        display: flex;
        align-items: flex-start;
        gap: 10px;
        transition: border-color 0.15s ease, background 0.15s ease,
          box-shadow 0.15s ease;
      }

      .choice:hover {
        border-color: rgba(79, 70, 229, 0.35);
        background: rgba(79, 70, 229, 0.05);
        box-shadow: inset 0 0 0 1px rgba(79, 70, 229, 0.12);
      }

      .choice.correct {
        border-color: rgba(22, 163, 74, 0.7);
        background: rgba(22, 163, 74, 0.08);
      }

      .choice.incorrect {
        border-color: rgba(220, 38, 38, 0.7);
        background: rgba(220, 38, 38, 0.08);
      }

      .choice .label {
        flex: 1;
      }

      .choice .badge {
        font-size: 12px;
        color: var(--muted);
      }

      .controls {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 14px 20px;
        border-top: 1px solid var(--border);
        background: linear-gradient(
          0deg,
          rgba(0, 0, 0, 0.02),
          rgba(0, 0, 0, 0)
        );
      }

      .left-controls,
      .right-controls {
        display: flex;
        gap: 10px;
        align-items: center;
      }

      button {
        background: linear-gradient(
          180deg,
          rgba(79, 70, 229, 0.92),
          rgba(79, 70, 229, 0.78)
        );
        color: white;
        border: none;
        padding: 10px 14px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
        letter-spacing: 0.2px;
        transition: transform 0.05s ease, opacity 0.2s ease,
          box-shadow 0.15s ease;
        box-shadow: 0 6px 18px rgba(79, 70, 229, 0.3);
      }

      button.secondary {
        background: #ffffff;
        color: var(--text);
        border: 1px solid var(--border);
        box-shadow: 0 1px 0 rgba(0, 0, 0, 0.02);
      }

      button[disabled] {
        opacity: 0.5;
        cursor: not-allowed;
      }

      button:active {
        transform: translateY(1px);
      }

      .status {
        font-size: 14px;
        color: var(--muted);
      }

      .spinner-wrap {
        display: grid;
        place-items: center;
        height: 60vh;
      }

      .spinner {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        border: 4px solid rgba(0, 0, 0, 0.08);
        border-top-color: var(--accent);
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .hidden {
        display: none;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      /* Rendered markdown basics */
      code {
        background: rgba(0, 0, 0, 0.06);
        padding: 2px 6px;
        border-radius: 6px;
      }

      pre {
        background: rgba(0, 0, 0, 0.04);
        padding: 12px;
        border-radius: 10px;
        overflow: auto;
      }

      a {
        color: var(--accent-2);
      }

      select {
        background: #ffffff;
        color: var(--text);
        border: 1px solid var(--border);
        padding: 6px 8px;
        border-radius: 8px;
      }

      input[type="radio"],
      input[type="checkbox"] {
        transform: translateY(3px);
      }

      /* Better-looking upload dropzone */
      .dropzone {
        border: 2px dashed var(--border);
        border-radius: 14px;
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0.015),
          rgba(0, 0, 0, 0)
        );
        padding: 24px;
        display: grid;
        gap: 10px;
        place-items: center;
        text-align: center;
        cursor: pointer;
        transition: border-color 0.15s ease, background 0.15s ease,
          box-shadow 0.15s ease;
      }

      .dropzone:hover,
      .dropzone.hover {
        border-color: rgba(79, 70, 229, 0.45);
        background: rgba(79, 70, 229, 0.04);
        box-shadow: inset 0 0 0 1px rgba(79, 70, 229, 0.1);
      }

      .dz-icon {
        width: 40px;
        height: 40px;
        border-radius: 999px;
        display: grid;
        place-items: center;
        background: rgba(79, 70, 229, 0.08);
        color: var(--accent);
        font-weight: 700;
        box-shadow: 0 6px 18px rgba(79, 70, 229, 0.12) inset;
      }

      .dz-title {
        font-weight: 700;
      }

      .dz-subtitle {
        font-size: 14px;
        color: var(--muted);
      }

      /* Drag-and-drop ordering styles */
      .dnd-item {
        display: flex;
        align-items: center;
        gap: 10px;
        user-select: none;
      }

      .dnd-handle {
        width: 24px;
        height: 24px;
        border-radius: 6px;
        display: grid;
        place-items: center;
        background: rgba(0, 0, 0, 0.04);
        color: var(--muted);
        font-weight: 700;
        cursor: grab;
      }

      .dnd-item.dragging {
        opacity: 1;
      }

      .dnd-index {
        min-width: 28px;
        height: 24px;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.04);
        display: grid;
        place-items: center;
        font-size: 12px;
        color: var(--muted);
        font-weight: 600;
      }
    </style>
    <script>
      // Quiz logic kept self-contained and legible for future extension
      (function () {
        /** @typedef {{question: string, source: string, choices: {answer: string, text: string}[]}} RawQuestion */

        /** Global quiz state */
        const state = {
          questions: [],
          currentIndex: 0,
          // Stores responses per question index
          // single -> number (choice index)
          // multiple -> Set<number>
          // select -> Map<number, string>
          responses: new Map(),
          revealed: new Set(),
        };

        /** DOM refs */
        const refs = {};

        function $(sel) {
          return document.querySelector(sel);
        }

        function shuffle(array) {
          const arr = array.slice();
          for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
          return arr;
        }

        function isX(value) {
          return (
            String(value || "")
              .trim()
              .toLowerCase() === "x"
          );
        }

        function detectType(q) {
          const answers = q.choices
            .map((c) => c.answer)
            .filter((a) => String(a).trim() !== "");
          const xCount = answers.filter(isX).length;
          const hasNonX = answers.some((a) => !isX(a));
          if (answers.length > 0 && hasNonX && xCount === 0) return "select";
          if (xCount <= 1) return "single";
          return "multiple";
        }

        function buildSelectOptions(choices) {
          const distinct = Array.from(
            new Set(choices.map((c) => String(c.answer).trim()).filter(Boolean))
          );
          const allNumeric = distinct.every((v) => /^-?\d+(\.\d+)?$/.test(v));
          if (allNumeric) {
            return distinct.sort((a, b) => Number(a) - Number(b));
          }
          return distinct.sort((a, b) => a.localeCompare(b));
        }

        function buildQuizData(raw) {
          const shuffledQuestions = shuffle(raw);
          return shuffledQuestions.map((q, idx) => {
            const type = detectType(q);
            const choices = shuffle(
              q.choices.map((c, i) => ({ ...c, originalIndex: i }))
            );
            const selectOptions =
              type === "select" ? buildSelectOptions(choices) : [];
            return { ...q, type, choices, selectOptions, index: idx };
          });
        }

        function loadHtmlInto(el, html) {
          el.innerHTML = html;
        }

        function ensureResponseFor(index) {
          if (!state.responses.has(index)) {
            const q = state.questions[index];
            if (q.type === "single") state.responses.set(index, -1);
            else if (q.type === "multiple")
              state.responses.set(index, new Set());
            else if (q.type === "select") state.responses.set(index, new Map());
          }
        }

        function isQuestionAnswered(q, resp) {
          if (q.type === "single") {
            return typeof resp === "number" && resp >= 0;
          }
          if (q.type === "multiple") {
            return resp instanceof Set && resp.size > 0;
          }
          if (q.type === "select") {
            const map = resp instanceof Map ? resp : new Map();
            for (const v of map.values()) {
              if (String(v || "").trim() !== "") return true;
            }
            return false;
          }
          return false;
        }

        function countAnsweredQuestions() {
          let answered = 0;
          state.questions.forEach((q, idx) => {
            ensureResponseFor(idx);
            const resp = state.responses.get(idx);
            if (isQuestionAnswered(q, resp)) answered += 1;
          });
          return answered;
        }

        function onPrev() {
          if (state.currentIndex > 0) {
            state.currentIndex -= 1;
            render();
          }
        }

        function onNext() {
          if (state.currentIndex < state.questions.length - 1) {
            state.currentIndex += 1;
            render();
          } else {
            // Block finishing when nothing is answered
            if (countAnsweredQuestions() === 0) return;
            showResults();
          }
        }

        function onReveal() {
          const idx = state.currentIndex;
          if (state.revealed.has(idx)) {
            state.revealed.delete(idx);
          } else {
            state.revealed.add(idx);
          }
          renderChoices();
          updateRevealButton();
        }

        function updateRevealButton() {
          const isRevealed = state.revealed.has(state.currentIndex);
          refs.revealBtn.textContent = isRevealed ? "Unreveal" : "Reveal";
        }

        function renderHeader() {
          const q = state.questions[state.currentIndex];
          loadHtmlInto(
            refs.source,
            `<span class="dot"></span>${escapeHtml(q.source || "")}`
          );
          refs.progress.textContent = `Question ${state.currentIndex + 1} of ${
            state.questions.length
          }`;
        }

        function renderQuestion() {
          const q = state.questions[state.currentIndex];
          loadHtmlInto(refs.questionText, q.question || "");
        }

        function markChoiceEl(choiceEl, { correct, incorrect }) {
          choiceEl.classList.remove("correct", "incorrect");
          if (correct) choiceEl.classList.add("correct");
          if (incorrect) choiceEl.classList.add("incorrect");
        }

        function isChoiceCorrect(q, choice, resp) {
          if (q.type === "single" || q.type === "multiple")
            return isX(choice.answer);
          if (q.type === "select") {
            const selected = resp.get(choice.originalIndex) || "";
            return String(selected) === String(choice.answer);
          }
          return false;
        }

        function renderChoices() {
          const q = state.questions[state.currentIndex];
          const container = refs.choices;
          container.innerHTML = "";
          ensureResponseFor(state.currentIndex);
          const resp = state.responses.get(state.currentIndex);
          const revealed = state.revealed.has(state.currentIndex);

          if (q.type === "single") {
            q.choices.forEach((choice, idx) => {
              const id = `q${state.currentIndex}_r${idx}`;
              const wrapper = document.createElement("label");
              wrapper.className = "choice";
              wrapper.innerHTML = `
                <input type="radio" name="q_${state.currentIndex}" id="${id}" ${
                resp === idx ? "checked" : ""
              } />
                <div class="label">
                  <div class="text">${choice.text}</div>
                </div>
              `;
              const input = wrapper.querySelector("input");
              input.addEventListener("change", () => {
                state.responses.set(state.currentIndex, idx);
                if (revealed) renderChoices();
                renderControls();
              });
              if (revealed) {
                const correct = isChoiceCorrect(q, choice, resp);
                const incorrect = resp === idx && !correct;
                markChoiceEl(wrapper, { correct, incorrect });
              }
              container.appendChild(wrapper);
            });
          }

          if (q.type === "multiple") {
            q.choices.forEach((choice, idx) => {
              const id = `q${state.currentIndex}_c${idx}`;
              const checked = resp.has(idx);
              const wrapper = document.createElement("label");
              wrapper.className = "choice";
              wrapper.innerHTML = `
                <input type="checkbox" id="${id}" ${checked ? "checked" : ""} />
                <div class="label">
                  <div class="text">${choice.text}</div>
                </div>
              `;
              const input = wrapper.querySelector("input");
              input.addEventListener("change", (e) => {
                if (e.target.checked) resp.add(idx);
                else resp.delete(idx);
                if (revealed) renderChoices();
                renderControls();
              });
              if (revealed) {
                const correct = isChoiceCorrect(q, choice, resp);
                const incorrect = resp.has(idx) && !correct;
                markChoiceEl(wrapper, { correct, incorrect });
              }
              container.appendChild(wrapper);
            });
          }

          if (q.type === "select") {
            // Detect if answers form a 1..N ordering; if so, render drag-and-drop list
            const isNumeric = q.selectOptions.every((v) =>
              /^-?\d+(\.\d+)?$/.test(String(v))
            );
            const expectedCount = q.choices.length;
            const numericSorted = isNumeric
              ? q.selectOptions.map(Number).sort((a, b) => a - b)
              : [];
            const isPermutationOneToN =
              isNumeric &&
              numericSorted.length === expectedCount &&
              numericSorted.every((v, i) => v === i + 1);

            if (isPermutationOneToN) {
              // Build items sorted by current stored order
              const items = q.choices
                .slice()
                .sort(
                  (a, b) =>
                    (resp.get(a.originalIndex) || 0) -
                    (resp.get(b.originalIndex) || 0)
                );

              const buildItem = (choiceObj) => {
                const item = document.createElement("div");
                item.className = "choice dnd-item";
                item.setAttribute("data-oidx", String(choiceObj.originalIndex));
                item.draggable = !revealed;
                item.innerHTML = `
                  <div class="dnd-handle" aria-hidden="true">â‰¡</div>
                  <div class="label" style="flex:1">
                    <div class="text">${choiceObj.text}</div>
                  </div>
                `;
                if (revealed) {
                  const correct = isChoiceCorrect(q, choiceObj, resp);
                  const incorrect = !correct;
                  markChoiceEl(item, { correct, incorrect });
                }
                return item;
              };

              const updateMapFromDom = () => {
                const children = Array.from(
                  container.querySelectorAll(".dnd-item")
                );
                children.forEach((el, idx) => {
                  const oidx = Number(el.getAttribute("data-oidx"));
                  resp.set(oidx, idx + 1);
                });
              };

              const updateIndices = () => {
                const children = Array.from(
                  container.querySelectorAll(".dnd-item")
                );
                children.forEach((el, idx) => {
                  const idxEl = el.querySelector(".dnd-index");
                  if (idxEl) idxEl.textContent = String(idx + 1);
                });
              };

              const getDragAfterElement = (parent, y) => {
                const draggableElements = [
                  ...parent.querySelectorAll(".dnd-item:not(.dragging)"),
                ];
                return draggableElements.reduce(
                  (closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;
                    if (offset < 0 && offset > closest.offset) {
                      return { offset, element: child };
                    } else {
                      return closest;
                    }
                  },
                  { offset: Number.NEGATIVE_INFINITY, element: null }
                ).element;
              };

              // Render items
              items.forEach((c) => container.appendChild(buildItem(c)));
              //updateIndices();

              if (!revealed) {
                let currentDragImage = null;
                container.addEventListener("dragstart", (e) => {
                  const target = e.target && e.target.closest(".dnd-item");
                  if (!target) return;
                  target.classList.add("dragging");
                  if (
                    e.dataTransfer &&
                    typeof e.dataTransfer.setDragImage === "function"
                  ) {
                    const clone = target.cloneNode(true);
                    clone.style.position = "absolute";
                    clone.style.pointerEvents = "none";
                    clone.style.top = "-9999px";
                    clone.style.left = "-9999px";
                    clone.style.width = target.offsetWidth + "px";
                    clone.style.height = target.offsetHeight + "px";
                    clone.style.opacity = "1";
                    clone.style.boxShadow = "0 8px 24px rgba(0,0,0,0.15)";
                    document.body.appendChild(clone);
                    currentDragImage = clone;
                    // Offset so cursor is near the handle
                    e.dataTransfer.setDragImage(
                      clone,
                      16,
                      Math.min(20, target.offsetHeight / 2)
                    );
                  }
                });
                container.addEventListener("dragend", (e) => {
                  const target = e.target && e.target.closest(".dnd-item");
                  if (target) target.classList.remove("dragging");
                  updateMapFromDom();
                  //updateIndices();
                  // Recompute controls as answered-state may have changed
                  renderControls();
                  if (currentDragImage && currentDragImage.parentNode) {
                    currentDragImage.parentNode.removeChild(currentDragImage);
                    currentDragImage = null;
                  }
                });
                container.addEventListener("dragover", (e) => {
                  e.preventDefault();
                  const dragging =
                    container.querySelector(".dnd-item.dragging");
                  if (!dragging) return;
                  const afterElement = getDragAfterElement(
                    container,
                    e.clientY
                  );
                  if (afterElement == null) {
                    container.appendChild(dragging);
                  } else {
                    container.insertBefore(dragging, afterElement);
                  }
                });
              }
            } else {
              // Fallback: original dropdown UI
              q.choices.forEach((choice) => {
                const wrapper = document.createElement("div");
                wrapper.className = "choice";
                const current = resp.get(choice.originalIndex) || "";
                const optionsHtml = [
                  '<option value="">Selectâ€¦</option>',
                  ...q.selectOptions.map(
                    (opt) =>
                      `<option value="${String(opt)}" ${
                        String(current) === String(opt) ? "selected" : ""
                      }>${String(opt)}</option>`
                  ),
                ].join("");
                wrapper.innerHTML = `
                  <div class="label" style="display:flex; gap:12px; align-items:flex-start; width:100%">
                    <div class="text" style="flex:1">${choice.text}</div>
                    <div>
                      <select aria-label="Select answer">
                        ${optionsHtml}
                      </select>
                    </div>
                  </div>
                `;
                const select = wrapper.querySelector("select");
                select.addEventListener("change", (e) => {
                  const value = e.target.value;
                  resp.set(choice.originalIndex, value);
                  if (revealed) renderChoices();
                  renderControls();
                });
                if (revealed) {
                  const correct = isChoiceCorrect(q, choice, resp);
                  const incorrect =
                    !correct && (resp.get(choice.originalIndex) || "") !== "";
                  markChoiceEl(wrapper, { correct, incorrect });
                }
                container.appendChild(wrapper);
              });
            }
          }
        }

        function renderControls() {
          refs.prevBtn.disabled = state.currentIndex === 0;
          // Never disable next on the last question; turn it into "Finish"
          const isLast = state.currentIndex === state.questions.length - 1;
          refs.nextBtn.disabled = isLast && countAnsweredQuestions() === 0;
          refs.nextBtn.textContent = isLast ? "Finish" : "Next";
          updateRevealButton();
        }

        function handleNumericChoiceKey(key) {
          const quizVisible =
            refs.quiz && !refs.quiz.classList.contains("hidden");
          if (!quizVisible) return;
          // Map '1'..'9' -> 0..8, '0' -> 9
          if (!/^\d$/.test(key)) return;
          const number = Number(key);
          const targetIdx = number === 0 ? 9 : number - 1;
          const q = state.questions[state.currentIndex];
          if (!q || targetIdx < 0 || targetIdx >= q.choices.length) return;
          ensureResponseFor(state.currentIndex);
          const revealed = state.revealed.has(state.currentIndex);
          if (q.type === "single") {
            const current = state.responses.get(state.currentIndex);
            if (current === targetIdx) {
              // Toggle off if same radio pressed
              state.responses.set(state.currentIndex, -1);
              if (revealed) renderChoices();
              renderControls();
              return;
            }
            const radios = refs.choices.querySelectorAll('input[type="radio"]');
            if (radios && radios[targetIdx]) {
              radios[targetIdx].click();
            } else {
              // Fallback: set state and re-render
              state.responses.set(state.currentIndex, targetIdx);
              if (revealed) renderChoices();
              renderControls();
            }
          } else if (q.type === "multiple") {
            const checkboxes = refs.choices.querySelectorAll(
              'input[type="checkbox"]'
            );
            if (checkboxes && checkboxes[targetIdx]) {
              // Click to toggle and trigger existing listeners
              checkboxes[targetIdx].click();
            } else {
              // Fallback: toggle state directly
              const resp = state.responses.get(state.currentIndex);
              if (resp instanceof Set) {
                if (resp.has(targetIdx)) resp.delete(targetIdx);
                else resp.add(targetIdx);
                if (revealed) renderChoices();
                renderControls();
              }
            }
          }
        }

        function render() {
          renderHeader();
          renderQuestion();
          renderChoices();
          renderControls();
        }

        function startQuizFromText(text) {
          const spinner = $("#spinner");
          const quiz = $("#quiz");
          const uploader = $("#uploader");
          spinner.classList.remove("hidden");
          quiz.classList.add("hidden");
          try {
            const rawQuestions = parseQuestionsFile(text);
            if (!rawQuestions || !rawQuestions.length) {
              throw new Error("No questions found in file");
            }
            state.questions = buildQuizData(rawQuestions);
            state.currentIndex = 0;
            state.responses = new Map();
            state.revealed = new Set();
            ensureResponseFor(0);
            render();
            if (uploader) uploader.classList.add("hidden");
            quiz.classList.remove("hidden");
          } catch (err) {
            console.error(err);
            const statusEl = $("#uploadStatus");
            if (statusEl)
              statusEl.textContent =
                "Failed to load file. " +
                (err && err.message ? err.message : "");
          } finally {
            spinner.classList.add("hidden");
          }
        }

        function getQuestionCorrectness(q, resp) {
          if (q.type === "single") {
            if (typeof resp !== "number" || resp < 0) return false;
            const choice = q.choices[resp];
            return !!choice && isX(choice.answer);
          }
          if (q.type === "multiple") {
            const selected = resp instanceof Set ? resp : new Set();
            const correctIdx = new Set(
              q.choices
                .map((c, i) => (isX(c.answer) ? i : -1))
                .filter((i) => i !== -1)
            );
            if (selected.size !== correctIdx.size) return false;
            for (const i of selected) {
              if (!correctIdx.has(i)) return false;
            }
            return true;
          }
          if (q.type === "select") {
            const map = resp instanceof Map ? resp : new Map();
            // All rows must match their expected answer
            return q.choices.every(
              (c) => String(map.get(c.originalIndex) || "") === String(c.answer)
            );
          }
          return false;
        }

        function computeResults() {
          let correctCount = 0;
          let answeredCount = 0;
          let skipped = 0;
          /** @type {{questionIndex:number, question:any, type:string, details:any}[]} */
          const wrong = [];
          state.questions.forEach((q, idx) => {
            ensureResponseFor(idx);
            const resp = state.responses.get(idx);
            const answered = isQuestionAnswered(q, resp);
            if (!answered) {
              skipped += 1;
              return;
            } // skip entirely
            answeredCount += 1;
            const isCorrect = getQuestionCorrectness(q, resp);
            if (isCorrect) {
              correctCount += 1;
            } else {
              // Build details for review (exclude skipped)
              if (q.type === "single") {
                const selectedIdx = typeof resp === "number" ? resp : -1;
                const your =
                  selectedIdx >= 0 ? q.choices[selectedIdx]?.text || "" : "";
                const correct =
                  q.choices.find((c) => isX(c.answer))?.text || "";
                wrong.push({
                  questionIndex: idx,
                  question: q.question,
                  type: q.type,
                  details: { your, correct },
                });
              } else if (q.type === "multiple") {
                const selected = resp instanceof Set ? Array.from(resp) : [];
                const your = selected
                  .map((i) => q.choices[i]?.text || "")
                  .join("<br/>");
                const correct = q.choices
                  .map((c, i) => (isX(c.answer) ? q.choices[i].text : null))
                  .filter(Boolean)
                  .join("<br/>");
                wrong.push({
                  questionIndex: idx,
                  question: q.question,
                  type: q.type,
                  details: { your, correct },
                });
              } else if (q.type === "select") {
                const map = resp instanceof Map ? resp : new Map();
                const rows = q.choices.map((c) => ({
                  text: c.text,
                  your: String(map.get(c.originalIndex) || ""),
                  correct: String(c.answer),
                }));
                wrong.push({
                  questionIndex: idx,
                  question: q.question,
                  type: q.type,
                  details: { rows },
                });
              }
            }
          });
          const total = answeredCount;
          const percent =
            total > 0 ? Math.round((correctCount / total) * 100) : 0;
          return { correctCount, total, percent, wrong, skipped };
        }

        function buildResultsHtml(results) {
          const { correctCount, total, percent, wrong, skipped } = results;
          const header = `<div class="card-header"><div class="source"><span class="dot"></span>Results</div><div class="progress">Score: ${correctCount}/${total} (${percent}%)</div></div>`;

          const reviewItems = wrong
            .map((w, i) => {
              if (w.type === "select") {
                const rowsHtml = w.details.rows
                  .slice()
                  .sort((a, b) => {
                    // Try to sort numerically if possible, else lexically
                    const aNum = parseFloat(a.correct);
                    const bNum = parseFloat(b.correct);
                    if (!isNaN(aNum) && !isNaN(bNum)) {
                      return aNum - bNum;
                    }
                    return String(a.correct).localeCompare(String(b.correct));
                  })
                  .map(
                    (r) => `
                  <tr>
                    <td style="vertical-align:top; padding:6px 8px 6px 0; width:55%">${
                      r.text
                    }</td>
                    <td style="vertical-align:top; padding:6px 8px; color: var(--red)">${escapeHtml(
                      r.your || "(no selection)"
                    )}</td>
                    <td style="vertical-align:top; padding:6px 0; color: var(--green)">${escapeHtml(
                      r.correct
                    )}</td>
                  </tr>
                `
                  )
                  .join("");
                return `
                <div class="card-body" style="border-top:1px solid var(--border)">
                  <div class="question-text" style="margin-bottom:8px"><b>Question ${
                    w.questionIndex + 1
                  }:</b><br/>${w.question}</div>
                  <div style="overflow:auto">
                    <table style="width:100%; border-collapse:collapse; font-size:14px">
                      <thead>
                        <tr>
                          <th style="text-align:left; padding:6px 8px 6px 0; color:var(--muted); font-weight:600">Choice</th>
                          <th style="text-align:left; padding:6px 8px; color:var(--muted); font-weight:600">Your answer</th>
                          <th style="text-align:left; padding:6px 0; color:var(--muted); font-weight:600">Correct</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${rowsHtml}
                      </tbody>
                    </table>
                  </div>
                </div>`;
              }
              return `
              <div class="card-body" style="border-top:1px solid var(--border)">
                <div class="question-text" style="margin-bottom:8px"><b>Question ${
                  w.questionIndex + 1
                }:</b><br/>${w.question}</div>
                <div style="display:grid; gap:4px; font-size:14px">
                  <div><b>Your answer:</b><br/>${w.details.your}</div>
                  <div><b>Correct answer:</b><br/>${w.details.correct}</div>
                </div>
              </div>`;
            })
            .join("");

          const bodyTop = `
              <div class="card-body">
                <div class="question-text" style="margin:0">
                  Your score: <b>${percent}%</b> (${correctCount} / ${total}).
                  <br>
                  <span style="color:var(--muted); font-size:13px">
                    ${skipped} question${skipped === 1 ? "" : "s"} skipped
                  </span>
                </div>
              </div>`;

          const controls = `
              <div class="controls">
                <div class="left-controls">
                  <button id="restartBtn" class="secondary" type="button">Restart</button>
                </div>
                <div class="right-controls">
                  <div class="status"></div>
                  <button id="reviewToggleBtn" type="button">${
                    wrong.length ? "Show review" : "Done"
                  }</button>
                </div>
              </div>`;

          const reviewBlock = wrong.length ? reviewItems : ``;
          return header + bodyTop + reviewBlock + controls;
        }

        function showResults() {
          const quiz = $("#quiz");
          const resultsEl = $("#results");
          const results = computeResults();
          resultsEl.innerHTML = buildResultsHtml(results);
          quiz.classList.add("hidden");
          resultsEl.classList.remove("hidden");

          // Wire buttons
          const restartBtn = document.getElementById("restartBtn");
          if (restartBtn) {
            restartBtn.addEventListener("click", () => {
              // Reload the page to fully restart and reshuffle as on a fresh load
              window.location.reload();
            });
          }
          const reviewToggleBtn = document.getElementById("reviewToggleBtn");
          if (reviewToggleBtn) {
            if (reviewToggleBtn.textContent === "Done") {
              reviewToggleBtn.addEventListener("click", () => {
                // Same as restart for simplicity
                if (restartBtn) restartBtn.click();
              });
            } else {
              let showing = true;
              reviewToggleBtn.addEventListener("click", () => {
                showing = !showing;
                // Toggle visibility of review bodies (all but first body which is summary)
                resultsEl.querySelectorAll(".card-body").forEach((el, idx) => {
                  if (idx === 0) return; // keep summary
                  el.classList.toggle("hidden", !showing);
                });
                reviewToggleBtn.textContent = showing
                  ? "Hide review"
                  : "Show review";
              });
              // Start with review shown
              reviewToggleBtn.textContent = "Hide review";
            }
          }
        }

        function init() {
          refs.source = $("#source");
          refs.progress = $("#progress");
          refs.questionText = $("#questionText");
          refs.choices = $("#choices");
          refs.prevBtn = $("#prevBtn");
          refs.nextBtn = $("#nextBtn");
          refs.revealBtn = $("#revealBtn");
          refs.status = $("#status");
          refs.results = $("#results");
          refs.quiz = $("#quiz");
          refs.fileInput = $("#fileInput");
          refs.dropzone = $("#dropzone");
          refs.chooseBtn = $("#chooseBtn");
          refs.uploadStatus = $("#uploadStatus");
          refs.uploader = $("#uploader");
          refs.spinner = $("#spinner");

          refs.prevBtn.addEventListener("click", onPrev);
          refs.nextBtn.addEventListener("click", onNext);
          refs.revealBtn.addEventListener("click", onReveal);

          // Hide spinner initially; show uploader by default
          if (refs.spinner) refs.spinner.classList.add("hidden");
          if (refs.uploader) refs.uploader.classList.remove("hidden");

          function loadFile(file) {
            if (!file) return;
            if (refs.uploadStatus)
              refs.uploadStatus.textContent = "Loading " + file.name + "â€¦";
            refs.spinner.classList.remove("hidden");
            const reader = new FileReader();
            reader.onload = () =>
              startQuizFromText(String(reader.result || ""));
            reader.onerror = () => {
              refs.spinner.classList.add("hidden");
              if (refs.uploadStatus)
                refs.uploadStatus.textContent = "Failed to read file.";
            };
            reader.readAsText(file);
          }

          if (refs.fileInput) {
            refs.fileInput.addEventListener("change", () => {
              if (refs.uploadStatus) refs.uploadStatus.textContent = "";
              const file = refs.fileInput.files && refs.fileInput.files[0];
              if (file) loadFile(file);
            });
          }
          if (refs.dropzone) {
            const openPicker = () => refs.fileInput && refs.fileInput.click();
            refs.dropzone.addEventListener("click", openPicker);
            refs.dropzone.addEventListener("keydown", (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                openPicker();
              }
            });
            refs.dropzone.addEventListener("dragover", (e) => {
              e.preventDefault();
              refs.dropzone.classList.add("hover");
            });
            refs.dropzone.addEventListener("dragleave", () =>
              refs.dropzone.classList.remove("hover")
            );
            refs.dropzone.addEventListener("drop", (e) => {
              e.preventDefault();
              refs.dropzone.classList.remove("hover");
              const file =
                e.dataTransfer &&
                e.dataTransfer.files &&
                e.dataTransfer.files[0];
              if (file) loadFile(file);
            });
          }

          // Keyboard navigation: Left = Previous, Right/Space = Next
          document.addEventListener("keydown", (e) => {
            // Only when quiz is visible
            const quizVisible =
              refs.quiz && !refs.quiz.classList.contains("hidden");
            if (!quizVisible) return;
            // Ignore when typing in form fields or using modifiers
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            const target = e.target || document.activeElement;
            const tag = (
              target && target.tagName ? target.tagName : ""
            ).toLowerCase();
            const isTextEntryEl =
              (target && target.isContentEditable) ||
              tag === "select" ||
              tag === "textarea" ||
              tag === "button";
            // Disable native arrow navigation on input elements (e.g., radio/checkbox)
            if (
              tag === "input" &&
              (e.key === "ArrowLeft" ||
                e.key === "ArrowRight" ||
                e.key === "ArrowUp" ||
                e.key === "ArrowDown")
            ) {
              e.preventDefault();
            }
            if (isTextEntryEl) return;

            // Number keys -> toggle/select answers
            if (/^\d$/.test(e.key)) {
              e.preventDefault();
              handleNumericChoiceKey(e.key);
              return;
            }

            if (e.key === "ArrowLeft") {
              e.preventDefault();
              onPrev();
            } else if (e.key === "ArrowRight") {
              e.preventDefault();
              onNext();
            } else if (e.key === " " || e.key === "Spacebar") {
              e.preventDefault();
              onReveal();
            }
          });
        }

        window.addEventListener("DOMContentLoaded", init);
      })();
    </script>
  </head>

  <body>
    <div class="app">
      <div id="spinner" class="spinner-wrap hidden">
        <div class="spinner" aria-hidden="true"></div>
        <span class="sr-only">Loadingâ€¦</span>
      </div>
      <div id="uploader" class="card">
        <div class="card-header">
          <div class="source">
            <span class="dot"></span>Select a questions file
          </div>
          <div class="progress">Drop a file or choose one to begin</div>
        </div>
        <div class="card-body">
          <div
            id="dropzone"
            class="dropzone"
            tabindex="0"
            role="button"
            aria-label="Choose a questions file to start the quiz"
          >
            <div class="dz-icon">â†‘</div>
            <div class="dz-title">Drag & drop your file here</div>
            <div class="dz-subtitle">or click to choose a file</div>
          </div>
          <input
            id="fileInput"
            type="file"
            accept=".quiz,.txt,.*"
            style="
              position: absolute;
              width: 1px;
              height: 1px;
              padding: 0;
              margin: -1px;
              overflow: hidden;
              clip: rect(0, 0, 0, 0);
              border: 0;
            "
          />
          <div id="uploadStatus" class="status" style="margin-top: 12px"></div>
        </div>
        <div class="controls" style="justify-content: flex-end">
          <div class="right-controls">
            <div class="status"></div>
          </div>
        </div>
      </div>
      <div id="quiz" class="card hidden">
        <div class="card-header">
          <div id="source" class="source">
            <span class="dot"></span>Loadingâ€¦
          </div>
          <div id="progress" class="progress">Question 0 of 0</div>
        </div>
        <div class="card-body">
          <div id="questionText" class="question-text"></div>
          <div id="choices" class="choices"></div>
        </div>
        <div class="controls">
          <div class="left-controls">
            <button id="prevBtn" class="secondary" type="button">
              Previous
            </button>
            <button id="revealBtn" class="secondary" type="button">
              Reveal answers
            </button>
          </div>
          <div class="right-controls">
            <div id="status" class="status"></div>
            <button id="nextBtn" type="button">Next</button>
          </div>
        </div>
      </div>
      <div id="results" class="card hidden"></div>
    </div>
  </body>
</html>
